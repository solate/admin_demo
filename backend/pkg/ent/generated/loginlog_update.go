// Code generated by ent, DO NOT EDIT.

package generated

import (
	"admin_backend/pkg/ent/generated/loginlog"
	"admin_backend/pkg/ent/generated/predicate"
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// LoginLogUpdate is the builder for updating LoginLog entities.
type LoginLogUpdate struct {
	config
	hooks     []Hook
	mutation  *LoginLogMutation
	modifiers []func(*sql.UpdateBuilder)
}

// Where appends a list predicates to the LoginLogUpdate builder.
func (llu *LoginLogUpdate) Where(ps ...predicate.LoginLog) *LoginLogUpdate {
	llu.mutation.Where(ps...)
	return llu
}

// SetTenantCode sets the "tenant_code" field.
func (llu *LoginLogUpdate) SetTenantCode(s string) *LoginLogUpdate {
	llu.mutation.SetTenantCode(s)
	return llu
}

// SetNillableTenantCode sets the "tenant_code" field if the given value is not nil.
func (llu *LoginLogUpdate) SetNillableTenantCode(s *string) *LoginLogUpdate {
	if s != nil {
		llu.SetTenantCode(*s)
	}
	return llu
}

// SetUserID sets the "user_id" field.
func (llu *LoginLogUpdate) SetUserID(s string) *LoginLogUpdate {
	llu.mutation.SetUserID(s)
	return llu
}

// SetNillableUserID sets the "user_id" field if the given value is not nil.
func (llu *LoginLogUpdate) SetNillableUserID(s *string) *LoginLogUpdate {
	if s != nil {
		llu.SetUserID(*s)
	}
	return llu
}

// SetUserName sets the "user_name" field.
func (llu *LoginLogUpdate) SetUserName(s string) *LoginLogUpdate {
	llu.mutation.SetUserName(s)
	return llu
}

// SetNillableUserName sets the "user_name" field if the given value is not nil.
func (llu *LoginLogUpdate) SetNillableUserName(s *string) *LoginLogUpdate {
	if s != nil {
		llu.SetUserName(*s)
	}
	return llu
}

// SetIP sets the "ip" field.
func (llu *LoginLogUpdate) SetIP(s string) *LoginLogUpdate {
	llu.mutation.SetIP(s)
	return llu
}

// SetNillableIP sets the "ip" field if the given value is not nil.
func (llu *LoginLogUpdate) SetNillableIP(s *string) *LoginLogUpdate {
	if s != nil {
		llu.SetIP(*s)
	}
	return llu
}

// SetMessage sets the "message" field.
func (llu *LoginLogUpdate) SetMessage(s string) *LoginLogUpdate {
	llu.mutation.SetMessage(s)
	return llu
}

// SetNillableMessage sets the "message" field if the given value is not nil.
func (llu *LoginLogUpdate) SetNillableMessage(s *string) *LoginLogUpdate {
	if s != nil {
		llu.SetMessage(*s)
	}
	return llu
}

// ClearMessage clears the value of the "message" field.
func (llu *LoginLogUpdate) ClearMessage() *LoginLogUpdate {
	llu.mutation.ClearMessage()
	return llu
}

// SetUserAgent sets the "user_agent" field.
func (llu *LoginLogUpdate) SetUserAgent(s string) *LoginLogUpdate {
	llu.mutation.SetUserAgent(s)
	return llu
}

// SetNillableUserAgent sets the "user_agent" field if the given value is not nil.
func (llu *LoginLogUpdate) SetNillableUserAgent(s *string) *LoginLogUpdate {
	if s != nil {
		llu.SetUserAgent(*s)
	}
	return llu
}

// ClearUserAgent clears the value of the "user_agent" field.
func (llu *LoginLogUpdate) ClearUserAgent() *LoginLogUpdate {
	llu.mutation.ClearUserAgent()
	return llu
}

// SetBrowser sets the "browser" field.
func (llu *LoginLogUpdate) SetBrowser(s string) *LoginLogUpdate {
	llu.mutation.SetBrowser(s)
	return llu
}

// SetNillableBrowser sets the "browser" field if the given value is not nil.
func (llu *LoginLogUpdate) SetNillableBrowser(s *string) *LoginLogUpdate {
	if s != nil {
		llu.SetBrowser(*s)
	}
	return llu
}

// ClearBrowser clears the value of the "browser" field.
func (llu *LoginLogUpdate) ClearBrowser() *LoginLogUpdate {
	llu.mutation.ClearBrowser()
	return llu
}

// SetOs sets the "os" field.
func (llu *LoginLogUpdate) SetOs(s string) *LoginLogUpdate {
	llu.mutation.SetOs(s)
	return llu
}

// SetNillableOs sets the "os" field if the given value is not nil.
func (llu *LoginLogUpdate) SetNillableOs(s *string) *LoginLogUpdate {
	if s != nil {
		llu.SetOs(*s)
	}
	return llu
}

// ClearOs clears the value of the "os" field.
func (llu *LoginLogUpdate) ClearOs() *LoginLogUpdate {
	llu.mutation.ClearOs()
	return llu
}

// SetDevice sets the "device" field.
func (llu *LoginLogUpdate) SetDevice(s string) *LoginLogUpdate {
	llu.mutation.SetDevice(s)
	return llu
}

// SetNillableDevice sets the "device" field if the given value is not nil.
func (llu *LoginLogUpdate) SetNillableDevice(s *string) *LoginLogUpdate {
	if s != nil {
		llu.SetDevice(*s)
	}
	return llu
}

// ClearDevice clears the value of the "device" field.
func (llu *LoginLogUpdate) ClearDevice() *LoginLogUpdate {
	llu.mutation.ClearDevice()
	return llu
}

// SetLoginTime sets the "login_time" field.
func (llu *LoginLogUpdate) SetLoginTime(i int64) *LoginLogUpdate {
	llu.mutation.ResetLoginTime()
	llu.mutation.SetLoginTime(i)
	return llu
}

// SetNillableLoginTime sets the "login_time" field if the given value is not nil.
func (llu *LoginLogUpdate) SetNillableLoginTime(i *int64) *LoginLogUpdate {
	if i != nil {
		llu.SetLoginTime(*i)
	}
	return llu
}

// AddLoginTime adds i to the "login_time" field.
func (llu *LoginLogUpdate) AddLoginTime(i int64) *LoginLogUpdate {
	llu.mutation.AddLoginTime(i)
	return llu
}

// ClearLoginTime clears the value of the "login_time" field.
func (llu *LoginLogUpdate) ClearLoginTime() *LoginLogUpdate {
	llu.mutation.ClearLoginTime()
	return llu
}

// Mutation returns the LoginLogMutation object of the builder.
func (llu *LoginLogUpdate) Mutation() *LoginLogMutation {
	return llu.mutation
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (llu *LoginLogUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, llu.sqlSave, llu.mutation, llu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (llu *LoginLogUpdate) SaveX(ctx context.Context) int {
	affected, err := llu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (llu *LoginLogUpdate) Exec(ctx context.Context) error {
	_, err := llu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (llu *LoginLogUpdate) ExecX(ctx context.Context) {
	if err := llu.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (llu *LoginLogUpdate) check() error {
	if v, ok := llu.mutation.TenantCode(); ok {
		if err := loginlog.TenantCodeValidator(v); err != nil {
			return &ValidationError{Name: "tenant_code", err: fmt.Errorf(`generated: validator failed for field "LoginLog.tenant_code": %w`, err)}
		}
	}
	if v, ok := llu.mutation.UserName(); ok {
		if err := loginlog.UserNameValidator(v); err != nil {
			return &ValidationError{Name: "user_name", err: fmt.Errorf(`generated: validator failed for field "LoginLog.user_name": %w`, err)}
		}
	}
	if v, ok := llu.mutation.IP(); ok {
		if err := loginlog.IPValidator(v); err != nil {
			return &ValidationError{Name: "ip", err: fmt.Errorf(`generated: validator failed for field "LoginLog.ip": %w`, err)}
		}
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (llu *LoginLogUpdate) Modify(modifiers ...func(u *sql.UpdateBuilder)) *LoginLogUpdate {
	llu.modifiers = append(llu.modifiers, modifiers...)
	return llu
}

func (llu *LoginLogUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := llu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(loginlog.Table, loginlog.Columns, sqlgraph.NewFieldSpec(loginlog.FieldID, field.TypeInt))
	if ps := llu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := llu.mutation.TenantCode(); ok {
		_spec.SetField(loginlog.FieldTenantCode, field.TypeString, value)
	}
	if value, ok := llu.mutation.UserID(); ok {
		_spec.SetField(loginlog.FieldUserID, field.TypeString, value)
	}
	if value, ok := llu.mutation.UserName(); ok {
		_spec.SetField(loginlog.FieldUserName, field.TypeString, value)
	}
	if value, ok := llu.mutation.IP(); ok {
		_spec.SetField(loginlog.FieldIP, field.TypeString, value)
	}
	if value, ok := llu.mutation.Message(); ok {
		_spec.SetField(loginlog.FieldMessage, field.TypeString, value)
	}
	if llu.mutation.MessageCleared() {
		_spec.ClearField(loginlog.FieldMessage, field.TypeString)
	}
	if value, ok := llu.mutation.UserAgent(); ok {
		_spec.SetField(loginlog.FieldUserAgent, field.TypeString, value)
	}
	if llu.mutation.UserAgentCleared() {
		_spec.ClearField(loginlog.FieldUserAgent, field.TypeString)
	}
	if value, ok := llu.mutation.Browser(); ok {
		_spec.SetField(loginlog.FieldBrowser, field.TypeString, value)
	}
	if llu.mutation.BrowserCleared() {
		_spec.ClearField(loginlog.FieldBrowser, field.TypeString)
	}
	if value, ok := llu.mutation.Os(); ok {
		_spec.SetField(loginlog.FieldOs, field.TypeString, value)
	}
	if llu.mutation.OsCleared() {
		_spec.ClearField(loginlog.FieldOs, field.TypeString)
	}
	if value, ok := llu.mutation.Device(); ok {
		_spec.SetField(loginlog.FieldDevice, field.TypeString, value)
	}
	if llu.mutation.DeviceCleared() {
		_spec.ClearField(loginlog.FieldDevice, field.TypeString)
	}
	if value, ok := llu.mutation.LoginTime(); ok {
		_spec.SetField(loginlog.FieldLoginTime, field.TypeInt64, value)
	}
	if value, ok := llu.mutation.AddedLoginTime(); ok {
		_spec.AddField(loginlog.FieldLoginTime, field.TypeInt64, value)
	}
	if llu.mutation.LoginTimeCleared() {
		_spec.ClearField(loginlog.FieldLoginTime, field.TypeInt64)
	}
	_spec.AddModifiers(llu.modifiers...)
	if n, err = sqlgraph.UpdateNodes(ctx, llu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{loginlog.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	llu.mutation.done = true
	return n, nil
}

// LoginLogUpdateOne is the builder for updating a single LoginLog entity.
type LoginLogUpdateOne struct {
	config
	fields    []string
	hooks     []Hook
	mutation  *LoginLogMutation
	modifiers []func(*sql.UpdateBuilder)
}

// SetTenantCode sets the "tenant_code" field.
func (lluo *LoginLogUpdateOne) SetTenantCode(s string) *LoginLogUpdateOne {
	lluo.mutation.SetTenantCode(s)
	return lluo
}

// SetNillableTenantCode sets the "tenant_code" field if the given value is not nil.
func (lluo *LoginLogUpdateOne) SetNillableTenantCode(s *string) *LoginLogUpdateOne {
	if s != nil {
		lluo.SetTenantCode(*s)
	}
	return lluo
}

// SetUserID sets the "user_id" field.
func (lluo *LoginLogUpdateOne) SetUserID(s string) *LoginLogUpdateOne {
	lluo.mutation.SetUserID(s)
	return lluo
}

// SetNillableUserID sets the "user_id" field if the given value is not nil.
func (lluo *LoginLogUpdateOne) SetNillableUserID(s *string) *LoginLogUpdateOne {
	if s != nil {
		lluo.SetUserID(*s)
	}
	return lluo
}

// SetUserName sets the "user_name" field.
func (lluo *LoginLogUpdateOne) SetUserName(s string) *LoginLogUpdateOne {
	lluo.mutation.SetUserName(s)
	return lluo
}

// SetNillableUserName sets the "user_name" field if the given value is not nil.
func (lluo *LoginLogUpdateOne) SetNillableUserName(s *string) *LoginLogUpdateOne {
	if s != nil {
		lluo.SetUserName(*s)
	}
	return lluo
}

// SetIP sets the "ip" field.
func (lluo *LoginLogUpdateOne) SetIP(s string) *LoginLogUpdateOne {
	lluo.mutation.SetIP(s)
	return lluo
}

// SetNillableIP sets the "ip" field if the given value is not nil.
func (lluo *LoginLogUpdateOne) SetNillableIP(s *string) *LoginLogUpdateOne {
	if s != nil {
		lluo.SetIP(*s)
	}
	return lluo
}

// SetMessage sets the "message" field.
func (lluo *LoginLogUpdateOne) SetMessage(s string) *LoginLogUpdateOne {
	lluo.mutation.SetMessage(s)
	return lluo
}

// SetNillableMessage sets the "message" field if the given value is not nil.
func (lluo *LoginLogUpdateOne) SetNillableMessage(s *string) *LoginLogUpdateOne {
	if s != nil {
		lluo.SetMessage(*s)
	}
	return lluo
}

// ClearMessage clears the value of the "message" field.
func (lluo *LoginLogUpdateOne) ClearMessage() *LoginLogUpdateOne {
	lluo.mutation.ClearMessage()
	return lluo
}

// SetUserAgent sets the "user_agent" field.
func (lluo *LoginLogUpdateOne) SetUserAgent(s string) *LoginLogUpdateOne {
	lluo.mutation.SetUserAgent(s)
	return lluo
}

// SetNillableUserAgent sets the "user_agent" field if the given value is not nil.
func (lluo *LoginLogUpdateOne) SetNillableUserAgent(s *string) *LoginLogUpdateOne {
	if s != nil {
		lluo.SetUserAgent(*s)
	}
	return lluo
}

// ClearUserAgent clears the value of the "user_agent" field.
func (lluo *LoginLogUpdateOne) ClearUserAgent() *LoginLogUpdateOne {
	lluo.mutation.ClearUserAgent()
	return lluo
}

// SetBrowser sets the "browser" field.
func (lluo *LoginLogUpdateOne) SetBrowser(s string) *LoginLogUpdateOne {
	lluo.mutation.SetBrowser(s)
	return lluo
}

// SetNillableBrowser sets the "browser" field if the given value is not nil.
func (lluo *LoginLogUpdateOne) SetNillableBrowser(s *string) *LoginLogUpdateOne {
	if s != nil {
		lluo.SetBrowser(*s)
	}
	return lluo
}

// ClearBrowser clears the value of the "browser" field.
func (lluo *LoginLogUpdateOne) ClearBrowser() *LoginLogUpdateOne {
	lluo.mutation.ClearBrowser()
	return lluo
}

// SetOs sets the "os" field.
func (lluo *LoginLogUpdateOne) SetOs(s string) *LoginLogUpdateOne {
	lluo.mutation.SetOs(s)
	return lluo
}

// SetNillableOs sets the "os" field if the given value is not nil.
func (lluo *LoginLogUpdateOne) SetNillableOs(s *string) *LoginLogUpdateOne {
	if s != nil {
		lluo.SetOs(*s)
	}
	return lluo
}

// ClearOs clears the value of the "os" field.
func (lluo *LoginLogUpdateOne) ClearOs() *LoginLogUpdateOne {
	lluo.mutation.ClearOs()
	return lluo
}

// SetDevice sets the "device" field.
func (lluo *LoginLogUpdateOne) SetDevice(s string) *LoginLogUpdateOne {
	lluo.mutation.SetDevice(s)
	return lluo
}

// SetNillableDevice sets the "device" field if the given value is not nil.
func (lluo *LoginLogUpdateOne) SetNillableDevice(s *string) *LoginLogUpdateOne {
	if s != nil {
		lluo.SetDevice(*s)
	}
	return lluo
}

// ClearDevice clears the value of the "device" field.
func (lluo *LoginLogUpdateOne) ClearDevice() *LoginLogUpdateOne {
	lluo.mutation.ClearDevice()
	return lluo
}

// SetLoginTime sets the "login_time" field.
func (lluo *LoginLogUpdateOne) SetLoginTime(i int64) *LoginLogUpdateOne {
	lluo.mutation.ResetLoginTime()
	lluo.mutation.SetLoginTime(i)
	return lluo
}

// SetNillableLoginTime sets the "login_time" field if the given value is not nil.
func (lluo *LoginLogUpdateOne) SetNillableLoginTime(i *int64) *LoginLogUpdateOne {
	if i != nil {
		lluo.SetLoginTime(*i)
	}
	return lluo
}

// AddLoginTime adds i to the "login_time" field.
func (lluo *LoginLogUpdateOne) AddLoginTime(i int64) *LoginLogUpdateOne {
	lluo.mutation.AddLoginTime(i)
	return lluo
}

// ClearLoginTime clears the value of the "login_time" field.
func (lluo *LoginLogUpdateOne) ClearLoginTime() *LoginLogUpdateOne {
	lluo.mutation.ClearLoginTime()
	return lluo
}

// Mutation returns the LoginLogMutation object of the builder.
func (lluo *LoginLogUpdateOne) Mutation() *LoginLogMutation {
	return lluo.mutation
}

// Where appends a list predicates to the LoginLogUpdate builder.
func (lluo *LoginLogUpdateOne) Where(ps ...predicate.LoginLog) *LoginLogUpdateOne {
	lluo.mutation.Where(ps...)
	return lluo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (lluo *LoginLogUpdateOne) Select(field string, fields ...string) *LoginLogUpdateOne {
	lluo.fields = append([]string{field}, fields...)
	return lluo
}

// Save executes the query and returns the updated LoginLog entity.
func (lluo *LoginLogUpdateOne) Save(ctx context.Context) (*LoginLog, error) {
	return withHooks(ctx, lluo.sqlSave, lluo.mutation, lluo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (lluo *LoginLogUpdateOne) SaveX(ctx context.Context) *LoginLog {
	node, err := lluo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (lluo *LoginLogUpdateOne) Exec(ctx context.Context) error {
	_, err := lluo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (lluo *LoginLogUpdateOne) ExecX(ctx context.Context) {
	if err := lluo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (lluo *LoginLogUpdateOne) check() error {
	if v, ok := lluo.mutation.TenantCode(); ok {
		if err := loginlog.TenantCodeValidator(v); err != nil {
			return &ValidationError{Name: "tenant_code", err: fmt.Errorf(`generated: validator failed for field "LoginLog.tenant_code": %w`, err)}
		}
	}
	if v, ok := lluo.mutation.UserName(); ok {
		if err := loginlog.UserNameValidator(v); err != nil {
			return &ValidationError{Name: "user_name", err: fmt.Errorf(`generated: validator failed for field "LoginLog.user_name": %w`, err)}
		}
	}
	if v, ok := lluo.mutation.IP(); ok {
		if err := loginlog.IPValidator(v); err != nil {
			return &ValidationError{Name: "ip", err: fmt.Errorf(`generated: validator failed for field "LoginLog.ip": %w`, err)}
		}
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (lluo *LoginLogUpdateOne) Modify(modifiers ...func(u *sql.UpdateBuilder)) *LoginLogUpdateOne {
	lluo.modifiers = append(lluo.modifiers, modifiers...)
	return lluo
}

func (lluo *LoginLogUpdateOne) sqlSave(ctx context.Context) (_node *LoginLog, err error) {
	if err := lluo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(loginlog.Table, loginlog.Columns, sqlgraph.NewFieldSpec(loginlog.FieldID, field.TypeInt))
	id, ok := lluo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`generated: missing "LoginLog.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := lluo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, loginlog.FieldID)
		for _, f := range fields {
			if !loginlog.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("generated: invalid field %q for query", f)}
			}
			if f != loginlog.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := lluo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := lluo.mutation.TenantCode(); ok {
		_spec.SetField(loginlog.FieldTenantCode, field.TypeString, value)
	}
	if value, ok := lluo.mutation.UserID(); ok {
		_spec.SetField(loginlog.FieldUserID, field.TypeString, value)
	}
	if value, ok := lluo.mutation.UserName(); ok {
		_spec.SetField(loginlog.FieldUserName, field.TypeString, value)
	}
	if value, ok := lluo.mutation.IP(); ok {
		_spec.SetField(loginlog.FieldIP, field.TypeString, value)
	}
	if value, ok := lluo.mutation.Message(); ok {
		_spec.SetField(loginlog.FieldMessage, field.TypeString, value)
	}
	if lluo.mutation.MessageCleared() {
		_spec.ClearField(loginlog.FieldMessage, field.TypeString)
	}
	if value, ok := lluo.mutation.UserAgent(); ok {
		_spec.SetField(loginlog.FieldUserAgent, field.TypeString, value)
	}
	if lluo.mutation.UserAgentCleared() {
		_spec.ClearField(loginlog.FieldUserAgent, field.TypeString)
	}
	if value, ok := lluo.mutation.Browser(); ok {
		_spec.SetField(loginlog.FieldBrowser, field.TypeString, value)
	}
	if lluo.mutation.BrowserCleared() {
		_spec.ClearField(loginlog.FieldBrowser, field.TypeString)
	}
	if value, ok := lluo.mutation.Os(); ok {
		_spec.SetField(loginlog.FieldOs, field.TypeString, value)
	}
	if lluo.mutation.OsCleared() {
		_spec.ClearField(loginlog.FieldOs, field.TypeString)
	}
	if value, ok := lluo.mutation.Device(); ok {
		_spec.SetField(loginlog.FieldDevice, field.TypeString, value)
	}
	if lluo.mutation.DeviceCleared() {
		_spec.ClearField(loginlog.FieldDevice, field.TypeString)
	}
	if value, ok := lluo.mutation.LoginTime(); ok {
		_spec.SetField(loginlog.FieldLoginTime, field.TypeInt64, value)
	}
	if value, ok := lluo.mutation.AddedLoginTime(); ok {
		_spec.AddField(loginlog.FieldLoginTime, field.TypeInt64, value)
	}
	if lluo.mutation.LoginTimeCleared() {
		_spec.ClearField(loginlog.FieldLoginTime, field.TypeInt64)
	}
	_spec.AddModifiers(lluo.modifiers...)
	_node = &LoginLog{config: lluo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, lluo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{loginlog.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	lluo.mutation.done = true
	return _node, nil
}
